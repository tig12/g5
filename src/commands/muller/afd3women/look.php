<?php
/********************************************************************************
    Code to examine data/tmp/muller/afd3-women/muller-afd3-women.csv
    (not the raw file, the intermediate file generated by raw2tmp.php).
    Not part of any build process - only to try to understand.
    
    To add a new function : 
        - add <entry> in POSSIBLE_PARAMS
        - implement a method named "look_<entry>"
    
    @license    GPL
    @history    2021-04-11, Thierry Graff : Creation
********************************************************************************/
namespace g5\commands\muller\afd3women;

use g5\patterns\Command;
use g5\model\DB5;
use tiglib\arrays\sortByKey;
use g5\commands\cura\Cura;

class look implements Command {
    
    /** 
        Possible values of the command, for ex :
        php run-g5.php muller afd3 look gauquelin
    **/
    const POSSIBLE_PARAMS = [
        'source',
        'gauquelin',
        'check',
        'occu',
    ];
    
    // *****************************************
    /** 
        Routes to the different actions, based on $param
        @param $params Array
                       First element indicates the method to execute ; must be one of self::POSSIBLE_PARAMS
                       Other elements are transmitted to the called method.
                       (Called methods are responsible to handle their params).
    **/
    public static function execute($params=[]): string{
        $possibleParams_str = implode(', ', self::POSSIBLE_PARAMS);
        if(count($params) == 0){
            return "PARAMETER MISSING\n"
                . "Possible values for parameter : $possibleParams_str\n";
        }
        $param = $params[0];
        if(!in_array($param, self::POSSIBLE_PARAMS)){
            return "INVALID PARAMETER\n"
                . "Possible values for parameter : $possibleParams_str\n";
        }
        
        $method = 'look_' . $param;
        
        if(count($params) > 1){
            array_shift($params);
            return self::$method($params);
        }
        
        return self::$method();
    }
    
    
    /**
        Checks columns SOURCE and GQ.
        SOURCE contains "primary source" and "secondary source".
    **/
    private static function look_source(){
        $report = '';
        $data = AFD3::loadTmpFile();
        $N = count($data);
        $NG = 0; // nb of record marked G in GQ column
        $source1 = array_fill_keys(['S', 'F', 'M'], 0); // primary source
        $source2 = array_fill_keys(['E', 'B', 'A', 'G'], 0); // secondary source
        $NStrange = 0;
        $reportStrange = '';
        foreach($data as $line){
            $s1 = substr($line['SOURCE'], 0, 1);
            $s2 = substr($line['SOURCE'], 1);
            $source1[$s1]++;
            $source2[$s2]++;
            $GQ = $line['GQ'];
            if($GQ == 'G'){
                $NG++;
            }
            if($GQ != 'G' && $s2 == 'G'){
                $reportStrange .=  "  {$line['SOURCE']} {$line['GQ']} {$line['MUID']}"
                    . " {$line['FNAME']} {$line['GNAME']}\t{$line['DATE']} {$line['OCCU']} \n";
                $NStrange++;
            }
        }
        $report .= "Primary source:\n";
        foreach($source1 as $k => $v){
            $report .= "  $k: $v\n";
        }
        $report .= "Secondary source:\n";
        foreach($source2 as $k => $v){
            $report .= "  $k: $v\n";
        }
        $report .= "$NStrange strange lines: secondary source contains 'G' but not marked 'G'\n";
        $report .= $reportStrange;
        $report .= "$NG lines marked 'G'\n";
        $NNoG = $N - $NG;
        $report .= "$NNoG lines not marked 'G'\n";
        return $report;
    }
    
    /**
        Lists persons supposed to be present in Gauquelin data.
        Match between Müller and Gauquelin is only done by birth day.
        Function written in an iterative process, to build variables $match and $incoherent.
        @pre    Gauquelin data must have been previously loaded in g5 database.
    **/
    private static function look_gauquelin(){
        $report = '';
        $data = AFD3::loadTmpFile();
        $dblink = DB5::getDbLink();
        $query = "select name,ids_in_sources,birth from person where birth->>'date-ut' like ? or birth->>'date' like ?";
        $stmt = $dblink->prepare($query);
        
        $N_total = 0; // total number of lines in Müller's file
        $N_gauq = 0; // total number of lines supposed to be in Gauquelin data
        $N_nogauq = 0; // total number of lines not supposed to be in Gauquelin data
        
        // Ambiguous cases fixed by hand from previous executions
        // Müller id => lerrcp id
        $match = [
            '011' => 'A1-129', // AURIOL Jacqueline *DOUET
            '018' => 'A6-72',  // BEAUVOIR Simone DE
            '046' => 'A6-210', // SIDONIE Gabrielle
            '050' => 'A5-215', // DARRIEUX Daniele
            '052' => 'D10-308', // DAY Doris
            '058' => 'A5-1084', // DORSCH Rathe
            '082' => 'A6-1098', // GEVERS Marie
            '109' => 'E3-834', // JOLIOT-CURIE Irene *CURIE
            '135' => 'A2-1974', // LINDEN Maria GFN VON
            '160' => 'E3-1107', // MOREAU Jeanne
            '161' => 'A5-568', // MORGAN Michele
            '171' => 'A6-601', // NOEL Marie
            '177' => 'A6-668', // RACHILDE *EYMERY Marguerite Vallette
            '183' => 'A5-690', // ROSAY Francoise
            '232' => 'A6-810', // YOURCENAR Marguerite
        ];
        $res_match = ''; // code to copy in class AFD3
        $N_match = 0;
        
        // Incoherent cases, filled by hand from previous execution
        // Contains Müller ids
        $incoherent = [
            '091', // GUILBERT Yvette
            '181', // ROCHEFORT Christiane
            '225', // WEIL Simone
        ];
        $N_incoherent = 0;
        $report_incoherent = '';
        
        // records supposed to be in Gauquelin data, but no match found
        $N_nomatch = 0;
        $report_nomatch = '';
        
        foreach($data as $line){
            $N_total++;
            $s1 = substr($line['SOURCE'], 0, 1);
            $s2 = substr($line['SOURCE'], 1);
            $GQ = $line['GQ'];
            if($GQ == 'N' && $s2 != 'G'){
                $N_nogauq++;
                continue;
            }
            //
            // here line should match with a Gauquelin record
            //
            $N_gauq++;
            $MUID = $line['MUID'];
            if(isset($match[$MUID])){
                // case manually fixed in $match
                $N_match++;
                $res_match .= "        '$MUID' => '{$match[$MUID]}', // {$line['FNAME']} {$line['GNAME']}\n";
                continue;
            }
            //
            // HERE query g5 database
            $param = substr($line['DATE'], 0, 10) . '%';
            $stmt->execute([$param, $param]);
            $res = $stmt->fetchAll(\PDO::FETCH_ASSOC);
            if(count($res) == 1){
                if(in_array($MUID, $incoherent)){
                    // case manually handled in $incoherent
                    $N_incoherent++;
                    $report_incoherent .= self::report_muller($line);
                }
                else{
                    $N_match++;
                    $ids_in_sources = json_decode($res[0]['ids_in_sources'], true);
                    $res_match .= "        '$MUID' => '{$ids_in_sources['cura5']}', // {$line['FNAME']} {$line['GNAME']}\n";
                }
            }
            else{
                // Zero match or several marches no handled by $match or $incoherent
                $N_nomatch++;
                $report_nomatch .= "\n" . self::report_muller($line);
                foreach($res as $candidate){
                    $report_nomatch .= self::report_gauquelin($candidate);
                }
            }
        }
        //
        $report .= "\n=== 1 match but incoherent:\n";
        $report .= $report_incoherent;
        //
        $report .= "\n=== Several matches => no match:\n";
        $report .= $report_nomatch;
        //
        $report .= "\n=== Coherent matches - code to copy in class AFD3:\n";
        $tmp = explode("\n", $res_match);
        sort($tmp);
        $report .= "    const MU_GQ = ["; // code to copy in class AFD3
        $report .= implode("\n", $tmp) . "\n";
        $report .= "    ];\n";
        //
        $report .= "--- According to Müller:\n";
        $report .= "N not Gauquelin = $N_nogauq\n";
        $report .= "N Gauquelin     = $N_gauq\n";
        $report .= "---\n";
        $report .= "N match         = $N_match\n";
        $report .= "N no match      = $N_nomatch\n";
        $report .= "N incoherent    = $N_incoherent\n";
        $report .= "---\n";
        $report .= "N total         = $N_total\n";
        $N_new = $N_total - $N_match;
        $report .= "N new           = $N_new\n";
        
        
        return $report;
    }
    
    /**
        Auxiliairy of look_gauquelin()
    **/
    private static function report_muller($line) {
        return "MU: {$line['MUID']}"
        . " {$line['FNAME']} {$line['GNAME']}"
        . " {$line['DATE']}"
        . " --- "
        . "{$line['PLACE']} ({$line['CY']})"
        . "\n";
    }
    
    /**
        Auxiliairy of look_gauquelin()
    **/
    private static function report_gauquelin($line) {
        $name = json_decode($line['name'], true);
        $birth = json_decode($line['birth'], true);
        $ids_in_sources = json_decode($line['ids_in_sources'], true);
        $date = $birth['date-ut'] ?? $birth['date'];
        return "GQ: {$ids_in_sources['cura5']}"
            . " {$name['family']} {$name['given']}"
            . " $date"
            . " --- "
            . " {$birth['place']['name']} ({$birth['place']['cy']})"
            . "\n";

    }
    
    // ******************************************************
    /**
        Command used to visually check the coherence of look_gauquelin()
        Prints Gauquelin and Müller records
        Constant AFD3::MU_GQ to retrieve the data fro g5 database.
    **/
    public static function look_check() {
        $report = '';
        $data = AFD3::loadTmpFile_muid();
        $dblink = DB5::getDbLink();
        $query = "select name,ids_in_sources,birth from person where ids_in_sources->>'" . Cura::SOURCE_SLUG . "'=?";
        $stmt = $dblink->prepare($query);
        
        foreach(AFD3::MU_GQ as $MUID => $GQID){
            $report .= "\n" . self::report_muller($data[$MUID]);
            $stmt->execute([$GQID]);
            $res = $stmt->fetchAll(\PDO::FETCH_ASSOC);
            if(count($res) > 1){
                throw new \Exception("Unexpected result for " . self::report_muller($data[$MUID]));
            }
            $report .= self::report_gauquelin($res[0]);
        }
        return $report;
    }
    
    // ******************************************************
    /**
        Echoes a list of occupation codes and the nb of associated persons
    **/
    public static function look_occu() {
        $data = AFD3::loadTmpFile();

        $occus = [];
        foreach($data as $line){
            $occu = $line['OCCU'];
            if(!isset($occus[$occu])){
                $occus[$occu] = 0;
            }
            $occus[$occu]++;
        }
        ksort($occus);
        $res = '';
        foreach($occus as $code => $nb){
            $res .= "        '$code' => '', // $nb persons\n";
        }
        return $res;
    }
    
}// end class
