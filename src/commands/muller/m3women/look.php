<?php
/********************************************************************************
    Code to examine data/tmp/muller/3-women/muller3-234-women.csv
    (not the raw file, the intermediate file generated by raw2tmp.php).
    Not part of any build process - only to try to understand.
    
    To add a new function : 
        - add <entry> in POSSIBLE_PARAMS
        - implement a method named "look_<entry>"
    
    @license    GPL
    @history    2021-04-11, Thierry Graff : Creation
********************************************************************************/
namespace g5\commands\muller\m3women;

use tiglib\patterns\Command;
use g5\model\DB5;
use tiglib\arrays\sortByKey;
use g5\commands\gauq\LERRCP;

class look implements Command {
    
    /** 
        Possible values of the command, for ex :
        php run-g5.php muller m3 look gauquelin
    **/
    const POSSIBLE_PARAMS = [
        'source',
        'gauquelin',
        'check',
        'occu',
    ];
    
    // *****************************************
    /** 
        Routes to the different actions, based on $param
        @param $params Array
                       First element indicates the method to execute ; must be one of self::POSSIBLE_PARAMS
                       Other elements are transmitted to the called method.
                       (Called methods are responsible to handle their params).
    **/
    public static function execute($params=[]): string{
        $possibleParams_str = implode(', ', self::POSSIBLE_PARAMS);
        if(count($params) == 0){
            return "PARAMETER MISSING\n"
                . "Possible values for parameter : $possibleParams_str\n";
        }
        $param = $params[0];
        if(!in_array($param, self::POSSIBLE_PARAMS)){
            return "INVALID PARAMETER\n"
                . "Possible values for parameter : $possibleParams_str\n";
        }
        
        $method = 'look_' . $param;
        
        if(count($params) > 1){
            array_shift($params);
            return self::$method($params);
        }
        
        return self::$method();
    }
    
    
    /**
        Checks columns SOURCE and GQ.
        SOURCE contains "primary source" and "secondary source".
    **/
    private static function look_source(){
        $report = '';
        $data = AFD3women::loadTmpFile();
        $N = count($data);
        $NG = 0; // nb of record marked G in GQ column
        $source1 = array_fill_keys(['S', 'F', 'M'], 0); // primary source
        $source2 = array_fill_keys(['E', 'B', 'A', 'G'], 0); // secondary source
        $NStrange = 0;
        $reportStrange = '';
        foreach($data as $line){
            $s1 = substr($line['SOURCE'], 0, 1);
            $s2 = substr($line['SOURCE'], 1);
            $source1[$s1]++;
            $source2[$s2]++;
            $GQ = $line['GQ'];
            if($GQ == 'G'){
                $NG++;
            }
            if($GQ != 'G' && $s2 == 'G'){
                $reportStrange .=  "  {$line['SOURCE']} {$line['GQ']} {$line['MUID']}"
                    . " {$line['FNAME']} {$line['GNAME']}\t{$line['DATE']} {$line['OCCU']} \n";
                $NStrange++;
            }
        }
        $report .= "Primary source:\n";
        foreach($source1 as $k => $v){
            $report .= "  $k: $v\n";
        }
        $report .= "Secondary source:\n";
        foreach($source2 as $k => $v){
            $report .= "  $k: $v\n";
        }
        $report .= "$NStrange strange lines: secondary source contains 'G' but not marked 'G'\n";
        $report .= $reportStrange;
        $report .= "$NG lines marked 'G'\n";
        $NNoG = $N - $NG;
        $report .= "$NNoG lines not marked 'G'\n";
        return $report;
    }
    
    /**
        Lists persons supposed to be present in Gauquelin data.
        Match between Müller and Gauquelin is only done by birth day.
        Function written in an iterative process, to build variables AFD3women::GQ_MATCH and AFD3women::GQ_NOMATCH.
        @pre    Gauquelin data must have been previously loaded in g5 database.
    **/
    private static function look_gauquelin(){
        $report = '';
        $data = AFD3women::loadTmpFile();
        $dblink = DB5::getDbLink();
        $query = "select name,ids_in_sources,birth from person where birth->>'date-ut' like ? or birth->>'date' like ?";
        $stmt = $dblink->prepare($query);
        
        $N_total = 0; // total number of lines in Müller's file
        // According to Müller:
        $N_supposed_gauq = 0; // total number of lines supposed to be in Gauquelin data
        $N_supposed_nogauq = 0; // total number of lines not supposed to be in Gauquelin data
        
        $res_match = ''; // code to copy in class AFD3women
        $N_match = 0;
        
        // records supposed to be in Gauquelin data, but no match found
        $N_unresolved_nomatch = 0;
        $report_unresolved = '';
        
        foreach($data as $line){
            $N_total++;
            $MUID = $line['MUID'];
            $s1 = substr($line['SOURCE'], 0, 1);
            $s2 = substr($line['SOURCE'], 1);
            $GQ = $line['GQ'];
            if($GQ == 'N' && $s2 != 'G'){
                $N_supposed_nogauq++;
                if(!isset(AFD3women::GQ_MATCH[$MUID])){
                    continue;
                }
                // else
                    // Marked not Gauquelin by Müller but in Gauquelin
                    // report ?
            }
            else {
                $N_supposed_gauq++;
            }
            //
            // here line should match with a Gauquelin record
            //
            if(isset(AFD3women::GQ_MATCH[$MUID])){
                $N_match++;
                $res_match .= "        '$MUID' => '" . AFD3women::GQ_MATCH[$MUID] . "', // {$line['FNAME']} {$line['GNAME']}\n";
                continue;
            }
            //
            if(in_array($MUID, AFD3women::GQ_NOMATCH)){
                continue;
            }
            //
            // HERE query g5 database to check in unresolved cases remain
            $param = substr($line['DATE'], 0, 10) . '%';
            $stmt->execute([$param, $param]);
            $res = $stmt->fetchAll(\PDO::FETCH_ASSOC);
            if(count($res) == 1){
                $N_match++;
                $ids_in_sources = json_decode($res[0]['ids_in_sources'], true);
                $res_match .= "        '$MUID' => '{$ids_in_sources[LERRCP::SOURCE_SLUG]}', // {$line['FNAME']} {$line['GNAME']}\n";
            }
            else{
                // not handled by $match or $nomatch
                // several possible matches, one match but different person
                $N_unresolved_nomatch++;
                $report_unresolved .= "\n" . self::report_muller($line);
                foreach($res as $candidate){
                    $report_unresolved .= self::report_gauquelin($candidate);
                }
            }
        }
        //
        if($report_unresolved){
            $report .= "\n=== Unresolved - fix in AFD3women::GQ_MATCH or GQ_NOMATCH:\n";
            $report .= $report_unresolved;
        }
        //
        $report .= "\n=== Coherent matches - code to copy in class AFD3women:\n";
        $tmp = explode("\n", $res_match);
        sort($tmp);
        $report .= "    const MU_MATCH = ["; // code to copy in class AFD3women
        $report .= implode("\n", $tmp) . "\n";
        $report .= "    ];\n";
        //
        $report .= "--- According to Müller ---\n";
        $report .= "N not Gauquelin     = $N_supposed_nogauq\n";
        $report .= "N Gauquelin         = $N_supposed_gauq\n";
        $report .= "--- Found by g5 ---\n";
        $report .= "N match Gauquelin   = $N_match\n";
        if($N_unresolved_nomatch != 0){
            $report .= "N no match Gq.  = $N_unresolved_nomatch\n";
        }
        $N_new = $N_total - $N_match;
        $report .= "N new               = $N_new\n";
        $report .= "N total             = $N_total\n";
        
        
        return $report;
    }
    
    /**
        Auxiliairy of look_gauquelin()
    **/
    private static function report_muller($line) {
        return str_pad("MU: {$line['MUID']}", 12)
        . " {$line['FNAME']} {$line['GNAME']}"
        . " {$line['DATE']}"
        . " --- "
        . "{$line['PLACE']} ({$line['CY']})"
        . "\n";
    }
    
    /**
        Auxiliairy of look_gauquelin()
    **/
    private static function report_gauquelin($line) {
        $name = json_decode($line['name'], true);
        $birth = json_decode($line['birth'], true);
        $ids_in_sources = json_decode($line['ids_in_sources'], true);
        $date = $birth['date-ut'] ?? $birth['date'];
        return str_pad("GQ: {$ids_in_sources[LERRCP::SOURCE_SLUG]}", 12)
            . " {$name['family']} {$name['given']}"
            . " $date"
            . " --- "
            . " {$birth['place']['name']} ({$birth['place']['cy']})"
            . "\n";

    }
    
    // ******************************************************
    /**
        Command used to visually check the coherence of look_gauquelin()
        Prints Gauquelin and Müller records
        Constant AFD3women::GQ_MATCH to retrieve the data fro g5 database.
    **/
    public static function look_check() {
        $report = '';
        $data = AFD3women::loadTmpFile_muid();
        $dblink = DB5::getDbLink();
        $query = "select name,ids_in_sources,birth from person where ids_in_sources->>'" . LERRCP::SOURCE_SLUG . "'=?";
        $stmt = $dblink->prepare($query);
        
        foreach(AFD3women::GQ_MATCH as $MUID => $GQID){
            $report .= "\n" . self::report_muller($data[$MUID]);
            $stmt->execute([$GQID]);
            $res = $stmt->fetchAll(\PDO::FETCH_ASSOC);
            if(count($res) > 1){
                throw new \Exception("Unexpected result for " . self::report_muller($data[$MUID]));
            }
            $report .= self::report_gauquelin($res[0]);
        }
        return $report;
    }
    
    // ******************************************************
    /**
        Echoes a list of occupation codes and the nb of associated persons
    **/
    public static function look_occu() {
        $data = AFD3women::loadTmpFile();

        $occus = [];
        foreach($data as $line){
            $occu = $line['OCCU'];
            if(!isset($occus[$occu])){
                $occus[$occu] = 0;
            }
            $occus[$occu]++;
        }
        ksort($occus);
        $res = '';
        foreach($occus as $code => $nb){
            $res .= "        '$code' => '', // $nb persons\n";
        }
        return $res;
    }
    
}// end class
